<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voice Agent</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>
<body>
    <div class="main-container">
        <div class="sidebar">
            <button id="startButton" class="mic-button">Start Voice Agent</button>
            <div id="status" class="status">Status: Inactive</div>
            <div class="audio-controls">
                <div class="device-select">
                    <label for="voiceModel">Voice Model:</label>
                    <select id="voiceModel"></select>
                </div>
            </div>
            <div class="controls">
                <label class="toggle">
                    <input type="checkbox" id="showLogs">
                    <span class="toggle-label">Show Logs</span>
                </label>
                <label class="toggle">
                    <input type="checkbox" id="darkMode" checked>
                    <span class="toggle-label">Dark Mode</span>
                </label>
            </div>
        </div>
        <div class="columns-container">
            <div id="conversation" class="timeline column">
                <h2>Conversation</h2>
                <div id="conversationMessages" class="timeline-messages"></div>
            </div>
            <div id="logs" class="timeline column" style="display: none;">
                <h2>Logs</h2>
                <div id="logMessages" class="timeline-messages"></div>
            </div>
        </div>
    </div>

    <script>
        const socket = io();
        const startButton = document.getElementById('startButton');
        const statusDiv = document.getElementById('status');
        const voiceModelSelect = document.getElementById('voiceModel');
        const conversationMessages = document.getElementById('conversationMessages');
        const logMessages = document.getElementById('logMessages');
        const showLogsToggle = document.getElementById('showLogs');
        const logsColumn = document.getElementById('logs');
        const darkModeToggle = document.getElementById('darkMode');

        let isActive = false;
        let audioContext;
        let audioWorkletNode;
        let microphone;
        let stream;

        let audioQueue = [];
        let isPlaying = false;
        let currentVoiceModel = 'aura-2-thalia-en';

        // --- Core Audio Logic ---
        async function startAudio() {
            if (isActive) {
                stopAudio();
                return;
            }
            console.log("Attempting to start audio...");
            statusDiv.textContent = 'Status: Initializing...';
            try {
                // 1. Get Microphone Access
                stream = await navigator.mediaDevices.getUserMedia({ 
                    audio: { sampleRate: 16000, channelCount: 1 }
                });
                console.log("Microphone access granted.");

                // 2. Create and Configure AudioContext and Worklet
                audioContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 16000 });
                console.log("AudioContext created.");

                await audioContext.audioWorklet.addModule('audio-processor.js');
                console.log("AudioWorklet module loaded.");
                
                microphone = audioContext.createMediaStreamSource(stream);
                audioWorkletNode = new AudioWorkletNode(audioContext, 'audio-processor');
                console.log("AudioWorkletNode created.");

                // 3. Set up the audio data pipeline
                audioWorkletNode.port.onmessage = (event) => {
                    if (isActive) {
                        socket.emit('user_audio', event.data);
                    }
                };
                console.log("Worklet message listener set up.");

                microphone.connect(audioWorkletNode);
                // DO NOT connect the worklet to the destination, to prevent feedback.
                console.log("Microphone connected to worklet.");

                // 4. Connect to the backend agent
                socket.emit('start_voice_agent', { voiceModel: currentVoiceModel });
                console.log("'start_voice_agent' event sent.");

                startButton.textContent = 'Stop Voice Agent';
                statusDiv.textContent = 'Status: Connecting...';
                isActive = true;

            } catch (err) {
                console.error('Error starting audio:', err);
                statusDiv.textContent = `Error: ${err.message}`;
                isActive = false;
            }
        }

        function stopAudio() {
            if (!isActive) return;
            console.log("Stopping audio...");
            socket.emit('stop_voice_agent');
            
            if (microphone) microphone.disconnect();
            if (audioWorkletNode) audioWorkletNode.disconnect();
            if (stream) stream.getTracks().forEach(track => track.stop());
            if (audioContext && audioContext.state !== 'closed') {
                audioContext.close();
            }

            audioQueue = [];
            isPlaying = false;
            startButton.textContent = 'Start Voice Agent';
            statusDiv.textContent = 'Status: Inactive';
            isActive = false;
            console.log("Audio stopped.");
        }

        async function playNextInQueue() {
            if (isPlaying || audioQueue.length === 0 || !audioContext) return;
            
            isPlaying = true;
            const audioData = audioQueue.shift();

            try {
                const audioBuffer = await audioContext.decodeAudioData(audioData);
                const source = audioContext.createBufferSource();
                source.buffer = audioBuffer;
                source.connect(audioContext.destination);
                source.onended = () => {
                    isPlaying = false;
                    playNextInQueue();
                };
                source.start();
            } catch (e) {
                console.error("Error decoding or playing audio:", e);
                isPlaying = false;
                playNextInQueue(); // Try the next item
            }
        }

        // --- Socket Event Handlers ---
        socket.on('agent_audio', (audioChunk) => {
            if (audioContext && audioChunk) {
                audioQueue.push(audioChunk);
                if (!isPlaying) {
                    playNextInQueue();
                }
            }
        });

        socket.on('agent_response', (data) => {
            console.log("Agent response received:", data);
            if(data.type === "Welcome") {
                statusDiv.textContent = "Status: Connected";
            }
            if(data.content) {
                addMessage(data.role || 'system', data.content, 'conversation');
            }
        });

        socket.on('log_message', (data) => {
            addMessage('log', data.message, 'log');
        });
        
        socket.on('disconnect', () => {
            console.log("Socket disconnected.");
            stopAudio();
            statusDiv.textContent = 'Status: Disconnected';
        });

        // --- UI and Helper Functions ---
        function addMessage(role, content, type) {
            const container = type === 'log' ? logMessages : conversationMessages;
            const messageDiv = document.createElement('div');
            messageDiv.className = `timeline-item message ${role}`;
            messageDiv.textContent = `${role}: ${content}`;
            container.appendChild(messageDiv);
            scrollToBottom(container);
        }
        
        function scrollToBottom(element) {
            element.scrollTop = element.scrollHeight;
        }

        function loadTTSModels() {
            fetch('/tts-models').then(response => response.json()).then(data => {
                if (data.error) {
                    console.error('Error loading TTS models:', data.error);
                    return;
                }
                voiceModelSelect.innerHTML = '';
                data.models.forEach(model => {
                    const option = document.createElement('option');
                    option.value = model.name;
                    option.text = `${model.display_name} (${model.language})`;
                    voiceModelSelect.appendChild(option);
                });
                voiceModelSelect.value = currentVoiceModel;
            }).catch(e => console.error("Failed to fetch TTS models:", e));
        }
        
        startButton.addEventListener('click', startAudio);
        voiceModelSelect.addEventListener('change', (e) => currentVoiceModel = e.target.value);
        showLogsToggle.addEventListener('change', () => {
            logsColumn.style.display = showLogsToggle.checked ? 'block' : 'none';
        });

        darkModeToggle.addEventListener('change', () => {
            document.body.classList.toggle('dark-mode', darkModeToggle.checked);
        });
        
        document.addEventListener('DOMContentLoaded', () => {
            loadTTSModels();
            document.body.classList.toggle('dark-mode', darkModeToggle.checked);
        });

    </script>
</body>
</html>