<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voice Agent</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>
<body>
    <div class="main-container">
        <div class="sidebar">
            <button id="startButton" class="mic-button">Start Voice Agent</button>
            <div id="status" class="status">Status: Inactive</div>
            <div class="audio-controls">
                <div class="device-select">
                    <label for="voiceModel">Voice Model:</label>
                    <select id="voiceModel"></select>
                </div>
            </div>
            <div class="controls">
                <label class="toggle">
                    <input type="checkbox" id="showLogs">
                    <span class="slider"></span>
                </label>
                <label for="showLogs" class="toggle-label">Show Debug Logs</label>
            </div>
            <hr>
            <div class="logs-container syncscroll" name="log-container" id="logsContainer" style="display: none;">
                <div id="logs" class="logs"></div>
            </div>
        </div>
        <div class="content-container syncscroll" name="log-container">
            <div id="conversation" class="conversation-panel"></div>
        </div>
    </div>

    <!-- Press to Speak Button -->
    <div class="speak-button-container">
        <button id="speakButton" class="speak-button" disabled>
            <span class="speak-button-text">Hold to Speak</span>
        </button>
    </div>

    <script>
        document.addEventListener("DOMContentLoaded", () => {
            const startButton = document.getElementById('startButton');
            const statusDiv = document.getElementById('status');
            const logsDiv = document.getElementById('logs');
            const conversationDiv = document.getElementById('conversation');
            const voiceModelSelect = document.getElementById('voiceModel');
            const showLogsCheckbox = document.getElementById('showLogs');
            const logsContainer = document.getElementById('logsContainer');
            const speakButton = document.getElementById('speakButton');

            let socket = null;
            let audioContext = null;
            let audioWorkletNode = null;
            let microphoneStream = null;
            let isActive = false;
            let isMuted = true; // Start muted, only speak when button is pressed
            let isAgentSpeaking = false; // Track when agent is playing audio
            let isAgentProcessing = false; // Track when agent is processing user input
            let audioQueue = [];
            let nextPlayTime = 0; // For continuous audio scheduling
            let lastAudioSendTime = 0;
            const AUDIO_SEND_INTERVAL = 20; // Send audio every 20ms (was 100ms - too aggressive)

            // --- UI and Logging ---

            function setStatus(message) {
                statusDiv.textContent = `Status: ${message}`;
            }

            function logMessage(message, type = 'info') {
                const timestamp = new Date().toLocaleTimeString();
                const logClass = type === 'error' ? 'log-error' : type === 'warn' ? 'log-warn' : type === 'user' ? 'log-user' : 'log-info';
                logsDiv.innerHTML += `<div class="${logClass}">[${timestamp}] ${message}</div>`;
                logsDiv.scrollTop = logsDiv.scrollHeight;
            }

            function addConversationMessage(role, text) {
                const messageBubble = document.createElement('div');
                messageBubble.className = `message-bubble ${role}`;
                messageBubble.textContent = text;
                conversationDiv.appendChild(messageBubble);
                conversationDiv.scrollTop = conversationDiv.scrollHeight;
            }

            // --- Scroll Syncing ---
            const syncScrollContainers = document.querySelectorAll('.syncscroll');
            syncScrollContainers.forEach(el => {
                el.addEventListener('scroll', () => {
                    const scrollY = el.scrollTop;
                    syncScrollContainers.forEach(otherEl => {
                        if (otherEl !== el) {
                            otherEl.scrollTop = scrollY;
                        }
                    });
                });
            });

            // --- API Calls ---

            async function fetchVoiceModels() {
                try {
                    const response = await fetch('/tts-models');
                    const data = await response.json();
                    if (data.models) {
                        voiceModelSelect.innerHTML = '';
                        data.models.forEach(model => {
                            const option = document.createElement('option');
                            option.value = model.name;
                            option.textContent = model.display_name;
                            voiceModelSelect.appendChild(option);
                        });
                        voiceModelSelect.value = 'aura-2-thalia-en'; // Default
                    } else {
                        logMessage('Failed to load voice models.', 'error');
                    }
                } catch (error) {
                    logMessage(`Error fetching voice models: ${error}`, 'error');
                }
            }
            
            // --- Core Audio Logic ---

            async function startAudio() {
                if (isActive) return;
                isActive = true;
                setStatus('Initializing...');
                logMessage('Starting audio pipeline...');

                try {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 16000 });
                    if (audioContext.state === 'suspended') await audioContext.resume();

                    await audioContext.audioWorklet.addModule('/audio-processor.js');
                    audioWorkletNode = new AudioWorkletNode(audioContext, 'audio-processor');

                    microphoneStream = await navigator.mediaDevices.getUserMedia({ audio: { sampleRate: 16000, channelCount: 1 }});
                    const microphone = audioContext.createMediaStreamSource(microphoneStream);
                    microphone.connect(audioWorkletNode);

                    audioWorkletNode.port.onmessage = (event) => {
                        if (socket && socket.connected && !isMuted && !isAgentSpeaking) {
                            // Send audio only when speak button is pressed and agent is not speaking
                            socket.emit('user_audio', event.data);
                            
                            // Log audio data being sent (occasionally)
                            if (Math.random() < 0.01) { // 1% of chunks
                                logMessage(`Sending user audio: ${event.data.byteLength} bytes`);
                            }
                        }
                    };
                    
                    logMessage('Audio pipeline ready.');
                    logMessage(`Microphone connected - Sample rate: ${audioContext.sampleRate}Hz`);
                    logMessage(`Audio mode: Press to Speak button only`);
                    connectSocket();

                } catch (error) {
                    logMessage(`Failed to start audio: ${error}`, 'error');
                    if (error.name === 'NotAllowedError') {
                        logMessage('Microphone permission denied. Please allow microphone access and try again.', 'error');
                    } else if (error.name === 'NotFoundError') {
                        logMessage('No microphone found. Please connect a microphone and try again.', 'error');
                    }
                    setStatus('Error');
                    isActive = false;
                }
            }

            function stopAudio() {
                if (!isActive) return;
                isActive = false;
                isAgentSpeaking = false;
                isAgentProcessing = false;
                isMuted = true;
                
                logMessage('Stopping audio pipeline...');
                if (socket) {
                    socket.emit('stop_voice_agent');
                    socket.disconnect();
                }
                if (microphoneStream) {
                    microphoneStream.getTracks().forEach(track => track.stop());
                }
                if (audioContext && audioContext.state !== 'closed') {
                    audioContext.close();
                }
                audioQueue = [];
                nextPlayTime = 0;
                
                setStatus('Inactive');
                startButton.textContent = 'Start Voice Agent';
                
                // Reset speak button to disabled state
                speakButton.disabled = true;
                speakButton.style.opacity = '0.6';
                speakButton.querySelector('.speak-button-text').textContent = 'Hold to Speak';
                speakButton.style.background = 'linear-gradient(135deg, #007bff, #0056b3)';
            }

            function playNextAudioChunk() {
                if (audioQueue.length === 0 || !audioContext) {
                    // Agent finished speaking - enable button for next user turn
                    if (isAgentSpeaking) {
                        setTimeout(() => {
                            if (audioQueue.length === 0) { // Double check after delay
                                isAgentSpeaking = false;
                                logMessage('Agent finished speaking');
                                setStatus('Agent Ready - Press button to speak');
                                speakButton.querySelector('.speak-button-text').textContent = 'Hold to Speak';
                                speakButton.style.background = 'linear-gradient(135deg, #007bff, #0056b3)';
                                updateSpeakButtonState(); // Re-enable button
                            }
                        }, 800); // Longer delay to ensure all audio is finished and prevent cutoff
                    }
                    return;
                }

                const audioData = audioQueue.shift();
                
                if (audioContext.state === 'suspended') {
                    audioContext.resume().then(() => {
                        playRawPCM(audioData);
                    });
                } else {
                    playRawPCM(audioData);
                }
            }

            function playRawPCM(audioData) {
                try {
                    // Convert Uint8Array to Int16Array (16-bit PCM)
                    const numSamples = audioData.length / 2;
                    const pcmData = new Int16Array(audioData.buffer, audioData.byteOffset, numSamples);
                    
                    // Create AudioBuffer
                    const audioBuffer = audioContext.createBuffer(1, numSamples, 24000);
                    const channelData = audioBuffer.getChannelData(0);
                    
                    // Convert Int16 to Float32 and fill the buffer
                    for (let i = 0; i < numSamples; i++) {
                        const sample = pcmData[i];
                        channelData[i] = sample / 32768.0;
                    }
                    
                    // Schedule the buffer for continuous playback
                    const source = audioContext.createBufferSource();
                    source.buffer = audioBuffer;
                    source.connect(audioContext.destination);
                    
                    // Calculate when to start this chunk for smooth playback
                    const currentTime = audioContext.currentTime;
                    if (nextPlayTime <= currentTime) {
                        nextPlayTime = currentTime + 0.05; // Larger buffer (50ms) to prevent cutoff
                    }
                    
                    source.start(nextPlayTime);
                    nextPlayTime += audioBuffer.duration; // Schedule next chunk right after this one
                    
                    // Log less frequently
                    if (Math.random() < 0.02) { // 2% of chunks
                        logMessage(`Playing audio chunk: ${numSamples} samples, scheduled at ${nextPlayTime.toFixed(3)}s`);
                    }
                    
                } catch (error) {
                    logMessage(`Error playing raw PCM: ${error}`, 'error');
                    console.error('Raw PCM playback error:', error);
                }
            }

            // --- WebSocket Logic ---

            function connectSocket() {
                if (socket && socket.connected) return;

                socket = io();

                socket.on('connect', () => {
                    logMessage('Socket connected successfully.');
                    setStatus('Connected, starting agent...');
                    const sessionConfig = {
                        voiceModel: voiceModelSelect.value,
                    };
                    socket.emit('start_voice_agent', sessionConfig);
                });

                socket.on('disconnect', () => {
                    logMessage('Socket disconnected.', 'warn');
                    stopAudio(); // Full cleanup on disconnect
                });

                socket.on('agent_response', (data) => {
                    logMessage(`Agent Response: ${JSON.stringify(data)}`);
                    switch (data.type) {
                        case 'Welcome':
                            setStatus('Agent Ready');
                            logMessage('Agent ready - waiting for greeting to finish');
                            // Don't enable button yet - wait for greeting audio to finish
                            break;
                        case 'ConversationText':
                            addConversationMessage('assistant', data.content);
                            // Agent is responding, so it's no longer processing user input
                            isAgentProcessing = false;
                            break;
                        case 'Error':
                            logMessage(`Agent Error: ${data.description}`, 'error');
                            setStatus('Error');
                            isAgentProcessing = false;
                            updateSpeakButtonState();
                            break;
                    }
                });

                socket.on('agent_audio', (chunk) => {
                    audioQueue.push(new Uint8Array(chunk));
                    // Start agent speaking if not already
                    if (!isAgentSpeaking) {
                        isAgentSpeaking = true;
                        isAgentProcessing = false; // No longer processing since agent is responding
                        logMessage('Agent speaking...');
                        setStatus('Agent speaking...');
                        updateSpeakButtonState(); // Disable button while agent speaks
                    }
                    playNextAudioChunk();
                });
            }

            // Function to update speak button state based on current conditions
            function updateSpeakButtonState() {
                const shouldEnable = isActive && !isAgentSpeaking && !isAgentProcessing;
                speakButton.disabled = !shouldEnable;
                speakButton.style.opacity = shouldEnable ? '1' : '0.6';
                
                if (shouldEnable) {
                    logMessage('Hold to Speak button enabled');
                } else {
                    logMessage(`Hold to Speak button disabled - Active: ${isActive}, Speaking: ${isAgentSpeaking}, Processing: ${isAgentProcessing}`);
                }
            }

            // Press-and-hold functionality for speak button
            function startSpeaking() {
                if (!isAgentSpeaking && !isAgentProcessing && isActive) {
                    isMuted = false;
                    logMessage('Speaking...', 'user');
                    setStatus('Listening...');
                    speakButton.querySelector('.speak-button-text').textContent = 'Speaking...';
                    speakButton.style.background = 'linear-gradient(135deg, #28a745, #1e7e34)';
                }
            }

            function stopSpeaking() {
                if (!isMuted) { // Only if we were actually speaking
                    isMuted = true;
                    isAgentProcessing = true; // Agent is now processing
                    logMessage('Stopped speaking - Agent processing...');
                    setStatus('Agent processing...');
                    speakButton.querySelector('.speak-button-text').textContent = 'Processing...';
                    speakButton.style.background = 'linear-gradient(135deg, #ffc107, #e0a800)';
                    updateSpeakButtonState(); // Disable button while processing
                }
            }

            // Mouse events
            speakButton.addEventListener('mousedown', (e) => {
                e.preventDefault();
                startSpeaking();
            });

            speakButton.addEventListener('mouseup', () => {
                stopSpeaking();
            });

            speakButton.addEventListener('mouseleave', () => {
                stopSpeaking();
            });

            // Touch events for mobile
            speakButton.addEventListener('touchstart', (e) => {
                e.preventDefault();
                startSpeaking();
            });

            speakButton.addEventListener('touchend', (e) => {
                e.preventDefault();
                stopSpeaking();
            });

            // Initialize speak button state
            speakButton.disabled = true;
            speakButton.style.opacity = '0.6';
            logMessage('Hold to Speak button initialized (disabled)');

            // --- Other Event Listeners ---

            startButton.addEventListener('click', () => {
                if (isActive) {
                    stopAudio();
                } else {
                    startAudio();
                    startButton.textContent = 'Stop Voice Agent';
                }
            });

            showLogsCheckbox.addEventListener('change', (e) => {
                if (e.target.checked) {
                    logsContainer.style.display = 'block';
                    logMessage('Debug logs are now visible');
                } else {
                    logsContainer.style.display = 'none';
                }
            });

            fetchVoiceModels();
        });
    </script>
</body>
</html>